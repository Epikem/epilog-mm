---
date: "2019-08-20"
title: "TIL 2019-08-20"
categories: "TIL"
tags: ["TIL"]
---

오늘 배운 것 & 한 것

----------

## sport

cf: 해설을 보는데 뭔가 알 듯도 한데 이해가 안 간다.

새로운 하노이 탑은 하도 안 되서 인터넷에 검색해봤는데 내 풀이랑 원리는 똑같은 것이 나왔다.
결국 파이썬의 한계인건가?? 분명 어딘가 병목이 있으리라 생각하고 별 최적화를 다 해봤지만 여전히 시간초과가 떴다. 그리고 양방향 탐색을 적용하면 틀려버린다..

파이썬 `copy.deepcopy`가 느리다고 해서 custom copy도 만들고, 기타등등 여러가지를 해봤지만 계속 시간초과가 났다. 입출력은 매우 작기 때문에 입출력이 원인일 리도 없다. 필요한 만큼의 시간복잡도를 썼을 뿐인데 실패하면 대체 어떻게 해야 하나??

### boj 12906 - 백조와 호수

그냥 주어진 대로 매번 녹이면서 탐색하면 시간초과. 유니온-파인드 원리를 이용해 얼음들을 녹이면서 효율적으로 물들이 만났는지 확인해야 한다.

어려움들:

- 물들을 dfs 탐색하면서 처음 그룹에 넣는건 어렵지 않았는데, 나중에 얼음을 녹이면서 그 관리가 어려웠다. 다음 연산들이 모두 효율적이어야 했기 때문이다:
- 1. 특정 칸의 그룹 찾기: `groupof[y][x]->int`배열을 사용.
- x. 특정 그룹의 모든 칸 찾기 `groupToCells[g]->list((y,x))` 배열을 사용. 그러나 나중에 필요없어졌다.
- 3. 두 백조의 그룹이 같은지 확인하기: 처음엔 그냥 `groupof[(pl1)]==groupof[(pl2)]`이렇게 구현했는데, 나중에 그룹 합치기가 문제가 되어 `getGroup(y,x)->int`함수를 만들었다.

아래는 최종 `getGroup`함수:

```py
def getGroup(y,x):
    if(y<0 or y>=r or x<0 or x>=c):
        return -1
    g = groupOf[y][x]
    lg = mergedGroup[g]
    gg = mergedGroup[mergedGroup[g]]
    while(lg!=gg):
        lg=gg
        gg=mergedGroup[lg]
    mergedGroup[g]=gg
    return gg
```

그리고 위의 연산들을 해야 하는 상황을 잘 구별해서 작성해야 한다.

- 5. 녹일 때 모든 주변 물 그룹들을 합쳐야 한다. set로 중복을 없게 넣은 다음 리스트로 만들어서 i,i+1 물 그룹들을 합쳐가는 방식으로 구현했다.
- 6. 얼음 녹일 때 주변 물 그룹의 번호를 부여해야 했다. 처음엔 `melt`함수에서 꺼내서 4방향을 탐색해서 그 번호들을 부여하려 했는데, 그렇게 되면 어느 우선순위로 할지 정해야 하고, 아예 처음에 `dfs`를 할 때 현재 위치가 물일 경우 주변 4방향을 녹일 타겟 큐에 넣는 것이므로, 녹일 타겟 정보에 현재 물의 그룹 번호를 같이 넣어주면 되었다.

예기치 못한 버그도 있었다:

- 1. 분명 예제에 그룹 7이 나올 수가 없는데 녹이면서 그룹7이 오른쪽 위 구석에 생겨났다. 그리고 녹이면서 한 쪽 끝에 있는 그룹이 다른쪽 그룹에 나타나는 경우가 생겼다. 왜인가 했더니, 파이썬 배열 인덱싱이 음수를 허용하기 때문이었다. 경계 체크를 하기 귀찮아서 try-except문으로 대신하려고 했는데 돌아가긴 돌아가길래 잘 되나 싶었는데 이것이 원인으로 위의 문제가 생긴 것이었다.

```py
...
  py,px=ny+dy[i],nx+dx[i]
  try:
    pg = groupOf[py][px] # 나중엔 getGroup함수 사용.
  except:
    pg = -1
  if(pg>0):
      nearGroups.add(pg)
  elif(pg==0):
      # it('putting next.', py,px,g)
      nextMeltQ.put((py,px,g))
...
```

이렇게 하게 되면, py나 px가 음수가 나와도, 마지막 값 등을 참조하게 되면서 코드는 작동은 되지만 이상하게 작동하게 된다. 따라서 파이썬 배열에서 경계 체크를 할 때는 반드시 일일히 if문으로 검사해야 한다.

여전히 실패하길래 대체 뭐가 문제지 하다가, 매 반복마다 녹이는 얼음의 개수를 띄워보니 얼음의 개수가 맵의 크기보다 커지고 있었다. 또 큐에 넣을 때 중복 검사를 해야한다는걸 잊은 것이다. 이걸 고치고 나니 훨씬 빨라졌는데 제출해보니 틀렸다고 뜬다. 질문을 찾아보니 53%에서 틀리면 백조 위치를 물로 고려하지 않을 경우 발생한다고 되어있었다. 분명 처음 물 그룹을 지정할 때는 백조의 위치도 물과 동일하게 처리했는데, 두번째 반복문에서 막상 얼음을 돌면서 주변 물을 찾을 때는 `'.'`으로 찾다 보니 백조는 무시된 것이었다. 이 부분을 고치자 드디어 통과했다.

다른 모범 답을 보니 훨씬 간단하게 백조의 큐, 물의 큐로 두 종류의 큐를 써서 (실제 큐는 각 큐마다 next큐가 필요해서 4개) 구현되어 있었다.

### boj 5213 - 과외맨

원리는 간단한 bfs인데, 구현이 힘들었다.
처음 구현할 때는 다음과 같이 구현했다:

1. 블럭 단위가 아니라 모든 숫자들을 맵으로 구현해서 가로로 2n, 세로로 n정도 되는 맵에 저장함.
1. 초기화 하면서 각 칸에는 그 칸의 숫자, 그 칸에 해당하는 블럭의 번호를 저장함
1. 탐색을 하면서 홀수면 왼쪽, 왼쪽 위, 왼쪽 아래, 오른쪽 칸을 체크, 짝수면 비슷하게 반대쪽으로 체크 하여 숫자가 같으면 큐에 집어넣음
1. 그런데 이렇게 했더니 같은 블럭에 해당하는 숫자를 알 수가 없었다. 그래서 만약 같은 블록이었다면 큐의 앞에 집어넣는게 아니라, 맨끝에 집어넣어서 바로 다음에 나올 수 있도록 집어넣음. (deque이기 때문에 가능)

이렇게 풀었는데, 틀려버렸다. 출처 테스트 케이스 중 4번을 집어넣으니 정답 코드는 169가 나오는데 내 코드는 185정도가 나왔다. 대체 왜일까. 분명 큐의 맨 끝에 집어넣었기 때문에 바로 다음에 나머지를 찾게 되니 문제는 없을거 같은데 라고 생각했지만 계속 틀렸기에 어쩔 수 없이 블럭 단위로 재구현하니 맞았다.

아무래도 큐의 맨 끝에 넣더라도, 한 칸에서 4방향 검사할 때 그런 현상이 중첩되면서 답이 틀어지는 경우가 생기는 모양이다.

코드를 버리기 아까워서 또는 정말 이것때문인지 확인하고 싶어서 방향벡터 for문 안에서 num이 같은 경우 다시 그 안에서 방향을 돌려서 해볼까 싶기도 했는데 포기하고 재구현했다.

- 배운 점: bfs에서 한 번에 탐색해야 하는 단계는 큐에 반드시 함께 넣어주어야 하며, 큐의 맨 끝에 넣는다고 해도 탐색 순서가 어긋날 수 있다.

## tags

\#sport, #algorithm, #boj

## new tips

-

<!---->



----------
